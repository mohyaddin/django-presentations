<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport">

    <title>Object Oriented Concepts</title>

    <link href="dist/reset.css" rel="stylesheet">
    <link href="dist/reveal.css" rel="stylesheet">
    <link href="dist/theme/black.css" rel="stylesheet">

    <!-- Theme used for syntax highlighted code -->
    <link href="plugin/highlight/monokai.css" rel="stylesheet">

    <style>
        .reveal h1 {
            text-transform: none;
        }

        .reveal h3 {
            text-transform: none;
        }
    </style>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section><h1>Object Oriented Concepts</h1></section>
        <section data-visibility="hidden">
            <h3>Outline</h3>
            <ul>
                <li></li>
                <li></li>
                <li></li>
            </ul>
        </section>
        <section>p
            <p>Object-Oriented Design (OOD) is a methodology for designing a system by visualizing it as a group of
                interacting objects. These objects represent real-world or conceptual entities, encapsulating both data
                and behavior. Below are some core concepts in Object-Oriented Design:</p>
        </section>
        <sectio>
            <h3>Classes and Objects</h3>
            <ul>
                <li>Class: A blueprint for creating objects (instances). It defines attributes (data) and methods
                    (behavior).
                </li>
                <li>Object: An instance of a class. Objects are the fundamental building blocks of OOD.</li>
            </ul>
        </sectio>
        <section>
            <pre><code>class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model

    def start_engine(self):
        print("Engine started")

my_car = Car("Toyota", "Corolla")
my_car.start_engine()</code></pre>
        </section>
        <section>
            <h3>Encapsulation</h3>
            <p>Encapsulation is the bundling of data and methods that operate on that data within one unit, typically a
                class. It restricts direct access to some of the object's components, which is a means of preventing
                accidental interference and misuse of the methods and data.</p>
        </section>
        <section>
            <pre><code>class BankAccount:
    def __init__(self, balance):
        self.__balance = balance  # Private attribute

    def deposit(self, amount):
        self.__balance += amount

    def get_balance(self):
        return self.__balance

account = BankAccount(1000)
account.deposit(500)
print(account.get_balance())  # Output: 1500</code></pre>
        </section>
        <section>
            <h3>Inheritance</h3>
            <p>Inheritance is a mechanism where a new class (subclass or derived class) inherits attributes and methods
                from an existing class (superclass or base class). This promotes code reuse.</p>
        </section>
        <section>
            <pre><code>class Animal:
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "Bark"

class Cat(Animal):
    def speak(self):
        return "Meow"

dog = Dog()
cat = Cat()
print(dog.speak())  # Output: Bark
print(cat.speak())  # Output: Meow</code></pre>
        </section>
        <section>
            <h3>Polymorphism</h3>
            <p>Polymorphism allows objects of different classes to be treated as objects of a common superclass. Itâ€™s
                often implemented using method overriding and interfaces, allowing for different behavior for the same
                method.</p>
        </section>
        <section>
            <pre><code>class Shape:
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * (self.radius ** 2)

shapes = [Rectangle(3, 4), Circle(5)]
for shape in shapes:
    print(shape.area())  # Outputs: 12 and 78.5</code></pre>
        </section>
        <section>
            <h3>Abstraction</h3>
            <p>Abstraction is the concept of hiding the complex implementation details and showing only the necessary
                features of the object. It helps in reducing programming complexity and effort.</p>
        </section>
        <section>
            <pre><code>from abc import ABC, abstractmethod

class Vehicle(ABC):
    @abstractmethod
    def start(self):
        pass

class Car(Vehicle):
    def start(self):
        print("Car started")

car = Car()
car.start()  # Output: Car started</code></pre>
        </section>
        <section>
            <h3>Composition</h3>
            <p>Composition is a design principle in which a class is composed of one or more objects of other classes in
                order to achieve complex functionality. It represents a "has-a" relationship.</p>
        </section>
        <section>
            <pre><code>class Engine:
    def start(self):
        print("Engine started")

class Car:
    def __init__(self, engine):
        self.engine = engine

    def start(self):
        self.engine.start()

engine = Engine()
car = Car(engine)
car.start()  # Output: Engine started</code></pre>
        </section>
        <section>
            <h3>Class Variables</h3>
            <p>Class variables are variables that are shared across all instances of a class. They are defined within the class but outside any instance methods. These variables are the same for every object of the class.</p>
        </section>
        <section>
            <pre><code>class Employee:
    company_name = "TechCorp"  # Class variable

    def __init__(self, name):
        self.name = name  # Instance variable

emp1 = Employee("Alice")
emp2 = Employee("Bob")
print(emp1.company_name)  # Output: TechCorp
print(emp2.company_name)  # Output: TechCorp

Employee.company_name = "NewTechCorp"
print(emp1.company_name)  # Output: NewTechCorp
print(emp2.company_name)  # Output: NewTechCorp</code></pre>
        </section>
        <section>
            <h3>Instance Variables</h3>
            <p>Instance variables are attributes that are unique to each instance of a class. They are typically defined in the __init__ method and can differ between instances.</p>
        </section>
        <section>
            <pre><code>class Employee:
    def __init__(self, name, salary):
        self.name = name  # Instance variable
        self.salary = salary  # Instance variable

emp1 = Employee("Alice", 50000)
emp2 = Employee("Bob", 60000)
print(emp1.name, emp1.salary)  # Output: Alice 50000
print(emp2.name, emp2.salary)  # Output: Bob 60000</code></pre>
        </section>
        <section>
            <h3>Static Methods</h3>
            <p>Static methods belong to a class rather than any instance of the class. They do not modify object state or class state, and are defined using the @staticmethod decorator. They are often used for utility functions that make sense to belong to the class but don't need to access instance or class variables.</p>
        </section>
        <section>
            <pre><code>class MathOperations:
    @staticmethod
    def add(x, y):
        return x + y

result = MathOperations.add(5, 10)
print(result)  # Output: 15</code></pre>
        </section>
        <section>
            <h3>Class Methods</h3>
            <p>Class methods are methods that operate on the class itself rather than on instances of the class. They are defined using the @classmethod decorator and take cls as the first parameter, which refers to the class.</p>
        </section>
        <section>
            <pre><code>class Employee:
    num_employees = 0

    def __init__(self, name):
        self.name = name
        Employee.num_employees += 1

    @classmethod
    def get_num_employees(cls):
        return cls.num_employees

emp1 = Employee("Alice")
emp2 = Employee("Bob")
print(Employee.get_num_employees())  # Output: 2</code></pre>
        </section>
        <section>
            <h3>Properties (Getters and Setters)</h3>
            <p>Properties allow for controlled access to instance variables by defining methods for getting and setting the value of a variable. The @property decorator is used to define a getter method, and @setter is used to define a setter method.
            </p>
        </section>
        <section>
            <pre><code>class Employee:
    def __init__(self, name, salary):
        self._name = name
        self._salary = salary

    @property
    def salary(self):
        return self._salary

    @salary.setter
    def salary(self, value):
        if value < 0:
            raise ValueError("Salary cannot be negative")
        self._salary = value

emp = Employee("Alice", 50000)
print(emp.salary)  # Output: 50000
emp.salary = 60000
print(emp.salary)  # Output: 60000</code></pre>
        </section>
        <section>
            <h3>Inheritance (Multiple Inheritance)</h3>
            <p>In addition to single inheritance, Python supports multiple inheritance, where a class can inherit from more than one class. This allows a class to inherit methods and attributes from multiple classes.
            </p>
        </section>
        <section>
            <pre><code>class Animal:
    def speak(self):
        return "Some sound"

class Flyable:
    def fly(self):
        return "Flying"

class Bird(Animal, Flyable):
    pass

bird = Bird()
print(bird.speak())  # Output: Some sound
print(bird.fly())    # Output: Flying
</code></pre>
        </section>

        <section>
            <p>These concepts are foundational to Object-Oriented Design and are used to create scalable, maintainable,
                and flexible software systems. Each concept works together to enable developers to model real-world
                scenarios effectively in their code.</p>
        </section>
        <section>
            <h3>Method Overloading (Pythonic Approach)</h3>
            <p>Python does not support traditional method overloading as in some other languages (e.g., Java). However, you can achieve similar functionality by using default arguments or variable-length arguments (*args and **kwargs).
            </p>
        </section>
        <section>
            <pre><code>class Calculator:
    def add(self, a, b, c=0):
        return a + b + c

calc = Calculator()
print(calc.add(2, 3))       # Output: 5
print(calc.add(2, 3, 4))    # Output: 9
</code></pre>
        </section>
        <section>
            <h3>Method Overriding</h3>
            <p>Method overriding occurs when a subclass provides a specific implementation of a method that is already defined in its superclass. The method in the subclass overrides the method in the superclass.</p>
        </section>
        <section>
            <pre><code>class Animal:
    def speak(self):
        return "Some sound"

class Dog(Animal):
    def speak(self):
        return "Bark"

dog = Dog()
print(dog.speak())  # Output: Bark</code></pre>
        </section>
        <section>
            <h3>Abstract Classes and Methods</h3>
            <p>Abstract classes are classes that cannot be instantiated and often contain one or more abstract methods. Abstract methods are methods declared in an abstract class that must be implemented by subclasses. This is enforced using the abc module.</p>
        </section>
        <section>
            <pre><code>from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "Bark"

dog = Dog()
print(dog.speak())  # Output: Bark</code></pre>
        </section>
        <section>
            <h3>Operator Overloading</h3>
            <p>Operator overloading allows you to define custom behavior for operators like +, -, *, etc., for your class objects by defining special methods such as __add__, __sub__, __mul__, etc.</p>
        </section>
        <section>
            <pre><code>class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)

    def __repr__(self):
        return f"Vector({self.x}, {self.y})"

v1 = Vector(2, 3)
v2 = Vector(5, 7)
print(v1 + v2)  # Output: Vector(7, 10)</code></pre>
        </section>
    </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
        slideNumber: 'c/t',
    });
</script>
</body>
</html>
